# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FenceSetterDialog
                                 A QGIS plugin
 Set border description of parcel
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-09-03
        git sha              : $Format:%H$
        copyright            : (C) 2022 by axinav
        email                : axinav@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, sys
from pathlib import Path
import logging

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.gui import QgsMapCanvas,  QgsRubberBand, QgsMapLayerComboBox
from qgis.core import (QgsMapLayerProxyModel, QgsGeometry, QgsWkbTypes, QgsLineString,
        QgsProject, QgsFields, QgsField, QgsVectorFileWriter, QgsFeature,
        QgsVectorLayer)
from qgis.PyQt.QtCore import Qt, QVariant
from qgis.PyQt.QtGui import QColor

class QgsMapLayerComboBox1(QgsMapLayerComboBox):
    def __init__(self):
        super().__init__()

    def currentLayer(self):
        layer = QgsVectorLayer('/home/alex/coding/qgis-utils/kad.shp', 'myLayer', 'ogr')
        return layer


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FENCE_TYPE = ['забор',
        'забор металлический',
        'забор кирпичный',
        'забор деревянный',
        'забор сетчатый',
        'стена здания',
        'межа',
        'по координатам']
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'fence_setter_dialog_base.ui'))

#logging.basicConfig(filename='/home/alex/.local/share/QGIS/QGIS3/profiles/default/python/plugins/fence_setter/app.log')
class FenceSetterDialog(QtWidgets.QDialog ):
    def __init__(self, parent=None):
        """Constructor."""
        super(FenceSetterDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        #self.setupUi(self)
        self.rubberList = []

        self.featIdLayout = QtWidgets.QHBoxLayout()
        featLabel = QtWidgets.QLabel('Feature Id')
        self.featSpinBox = QtWidgets.QSpinBox()
        self.featSpinBox.setDisabled(False)
        self.featIdLayout.addWidget(featLabel)
        self.featIdLayout.addWidget(self.featSpinBox)

        self.pointIdLayout = QtWidgets.QHBoxLayout()
        fromLabel = QtWidgets.QLabel('from')
        self.fromSpinBox = QtWidgets.QSpinBox()
        toLabel = QtWidgets.QLabel('to')
        self.toSpinBox = QtWidgets.QSpinBox()
        self.pointIdLayout.addWidget(fromLabel)
        self.pointIdLayout.addWidget(self.fromSpinBox)
        self.pointIdLayout.addWidget(toLabel)
        self.pointIdLayout.addWidget(self.toSpinBox)

        self.fenceDiscrCBox = QtWidgets.QComboBox()
        self.fenceDiscrCBox.addItems(FENCE_TYPE)

        self.addButtom = QtWidgets.QPushButton('Add')

        self.layerCBox = QgsMapLayerComboBox()
        self.layerCBox.setFilters(QgsMapLayerProxyModel.Filter.PolygonLayer)

        self.canvas = QgsMapCanvas()
        self.canvas.setCanvasColor(Qt.white)

        self.okButtom = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok
                | QtWidgets.QDialogButtonBox.Cancel)


        self.layout = QtWidgets.QGridLayout()
        self.layout.addWidget(self.layerCBox, 0, 0)
        self.layout.addWidget(self.canvas, 1, 0, 6, 1)
        self.layout.addLayout(self.featIdLayout, 0, 1)
        self.layout.addLayout(self.pointIdLayout, 1, 1)
        self.layout.addWidget(self.fenceDiscrCBox, 2, 1)
        self.layout.addWidget(self.addButtom, 3, 1)
        self.layout.addWidget(self.okButtom, 7, 0)

        self.setLayout(self.layout)
        self.setGeometry(700, 100, 400, 300)


        self.initLayerVar()


        self.layerCBox.layerChanged.connect(self.initLayerVar)
        self.fromSpinBox.valueChanged.connect(self.setToSpinBoxValue)
        self.toSpinBox.valueChanged.connect(self.setGeomCurRubbedBand)
        self.featSpinBox.valueChanged.connect(self.initFeatVar)
        self.addButtom.clicked.connect(self.addBorderDesc)
        self.okButtom.rejected.connect( self.cancel)
        self.okButtom.accepted.connect(self.accept)


    def cancel(self):

        for i in self.rubberList:
            self.canvas.scene().removeItem(i)
        self.reject()


    def addCurLayerToCanvas(self, curLayer):
        self.canvas.setExtent(curLayer.extent())
        self.canvas.setLayers([curLayer])


    def setMaxFeatSpinBox(self, curLayer):
        self.featSpinBox.setMaximum(curLayer.featureCount()-1)
        if  curLayer.featureCount()<2:
            self.featSpinBox.setDisabled(True)

    def setMaxPointId(self):
        featId = self.featSpinBox.value()
        curLayer = self.layerCBox.currentLayer()
        curGeom = curLayer.getGeometry(self.featSpinBox.value())
        maxN = self.getNumVertices(curGeom)
        self.toSpinBox.setMaximum(maxN)
        self.fromSpinBox.setMaximum(maxN-1)

    def getNumVertices(self, geom):
        return geom.constGet().nCoordinates()-1

    def setToSpinBoxValue(self):
        self.toSpinBox.setValue(self.fromSpinBox.value()+1)
        #self.toSpinBox.valueChanged.emit(1)
        self.setGeomCurRubbedBand()

    def setGeomCurRubbedBand(self):
        featId = self.featSpinBox.value()
        curLayer = self.layerCBox.currentLayer()
        curGeom = curLayer.getGeometry(self.featSpinBox.value())
        firstId = self.fromSpinBox.value()
        lastId = self.toSpinBox.value()
        points = []
        for n in  range(firstId, lastId+1):
            points.append(curGeom.vertexAt(n))
        self.curRubbedBand.setToGeometry(QgsGeometry.fromPolyline(points))
        self.curRubbedBand.setColor(QColor(Qt.yellow))
        self.curRubbedBand.setWidth(3)

    def setCanvasExtent(self):
        curLayer = self.layerCBox.currentLayer()
        curGeom = curLayer.getGeometry(self.featSpinBox.value())
        self.canvas.setExtent(curGeom.boundingBox())
        self.canvas.refresh()

    def addBorderDesc(self):
        r = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        r.setToGeometry(self.curRubbedBand.asGeometry())
        r.setColor(Qt.blue)
        r.setWidth(3)
        featId = self.featSpinBox.value()
        fromId = self.fromSpinBox.value()
        toId = self.toSpinBox.value()
        for i in range(fromId, toId):
            self.featBordDesc[i] = self.fenceDiscrCBox.currentText()
        self.fromSpinBox.setValue(self.toSpinBox.value())
        self.rubberList.append(r)
        
    def createBordersLinesDict(self,curLayer):
        listLines = {}
        for f in range(curLayer.featureCount()):
            geom = curLayer.getGeometry(f)
            lines = curLayer.getGeometry(f).coerceToType(QgsWkbTypes.LineString)
            vertSec = geom.constGet().coordinateSequence()
             
            nVertex = 0
            d={}
            for line in lines:
                for i,point in enumerate(line.vertices()):
                    if not line.vertexAt(i+1).isEmpty():
                        d[nVertex] = QgsLineString([point, line.vertexAt(i+1)])
                    nVertex = nVertex + 1
            listLines[f] = d
        return listLines

    def initLayerVar(self):
        try:
            self.canvas.scene().removeItem(self.curRubbedBand)
        except:
            pass
        self.curRubbedBand = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        self.allFeatDesc = {}
        curLayer = self.layerCBox.currentLayer()
        self.canvas.refreshAllLayers()
        self.addCurLayerToCanvas(curLayer)
        self.borderLines = self.createBordersLinesDict(curLayer)
        self.featSpinBox.setValue(0)
        self.featSpinBox.setDisabled(False)
        self.setMaxFeatSpinBox(curLayer)
        self.initFeatVar()

    def initFeatVar(self):
        self.featBordDesc = {}
        self.allFeatDesc[self.featSpinBox.value()] = self.featBordDesc
        self.setMaxPointId()
        self.fromSpinBox.setValue(0)
        self.setToSpinBoxValue()
        self.setCanvasExtent()

    def checkUp(self):
        text = ''
        checked = True


    def accept(self):
        curLayer = self.layerCBox.currentLayer()
        path = Path(curLayer.dataProvider().dataSourceUri()).parent
        name = Path(curLayer.dataProvider().dataSourceUri()).stem
        name = name + '_bordersDescr.shp'
        outName = str(Path(path, name))

        outFields = QgsFields()
        outFields.append(QgsField('featId', QVariant.Int))
        outFields.append(QgsField('firstPntId', QVariant.Int))
        outFields.append(QgsField('borderDesc', QVariant.String))
        crs = QgsProject.instance().crs()
        transform_context = QgsProject.instance().transformContext()
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"

        writer = QgsVectorFileWriter.create(
          outName,
          outFields,
          QgsWkbTypes.LineString,
          crs,
          transform_context,
          save_options
        )
        for key in self.allFeatDesc:
            featSegments = self.borderLines[key]
            featBorders = self.allFeatDesc[key]
            for k in featBorders:
                outFeat = QgsFeature()
                outFeat.setGeometry(featSegments[k])
                outFeat.setAttributes([key, k, featBorders[k]])
                writer.addFeature(outFeat)

        del writer
        for i in self.rubberList:
            self.canvas.scene().removeItem(i)
        borderLayer = QgsVectorLayer(outName, name.split('.')[0], 'ogr')
        QgsProject.instance().addMapLayer(borderLayer)
        self.close()







if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    wind = FenceSetterDialog()
    wind.show()
    sys.exit(app.exec_())
